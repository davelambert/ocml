* Translation

** To OWL

*** OWL species needs to be specifiable.

*** Support XSD types.

Claudio wants them.

** From OWL

Can use Wilbur, SWCLOS, or a homebrew on top of CXML.

** XML

*** Globals

Yuck!  Try not to use them.  As a first step, use lets in
generate-instances-from-xml and process-node instead of setf.

* Bugs

** base-ontology generates invalid XML in RDFS translation

It also doesn't display in webonto.  What's wrong with our most
fundamental ontology?!

** Constraint checking is broken due to finalise-ontology change

Constraint checking, like slot type computation, must be done *after*
the whole ontology is loaded.

* Features

** Java-Lisp interop

carlos would like something along the lines of jsr94, a java standard
for rule engine interfaces.  Perhaps we could use foil/jfli?

** ocml interface

we need something like the following

 (ocml:query-with-vars (goal thing)
    (blah balh goal thing foo))

where goal and thing are names of things in the local package, and the
other things (blah, balh, foo) all get moved into the ocml package for
the query.  this would elimnate the need for "ocml::" in correctly
formulated queries, and allow us to move to a sane ask/tell interface
for ocml.

** Forward chaining performance

The Rete system should be indexed.

** asktell

OCML> (ask (and (person ?x) (prone-to-cancer ?x))) =>

Solution:

 ((PERSON
 |http://example.open.ac.uk/ontologies/dave#parallel-universe-dave|)
 (PRONE-TO-CANCER
 |http://example.open.ac.uk/ontologies/dave#parallel-universe-dave|))

Shouldn't the *variables* be mentioned?

** union types

An outstanding OCML 7.3 -> 7.4/7.5 issue...

This is tagged with #+:ocml-irs-hacks conditionals in OCML.   We're
going to put union types back into OCML.  We believe they were only
removed to make the translation to RDF easier.

From John's email:

     union types were removed from OCML a little while ago but I
     didn't get my act together to remove them from some of our
     ontologies.

     I would say disable to check for now (if possible) and then we
     will clean up our ontologies.

     btw the solution is to create and use foo-bar-baz which inherits
     from foo-bar and foo-baz

On the other hand, Enrico says:

   The best way to handle this in OCML is to give the following
   definition to fooness

   (def-class fooness () ?x
    :iff-def  (or (foo-bar ?x) (foo-baz ?x)))

* Clean up

** Package hygiene

*** Less ::, more (export foo)

On the other hand, if we do that, symbols may not end up in the ocml
package, where they belong.

*** Move the internals to a new ocml-internal package.

The important bits could then be re-exported through the #:ocml
package, which would become the user's package.

** Specific code issues.

*** Remove get-domain-class or get-ocml-class, as per basic.lisp comment.

I prefer deleting get-ocml-class.  It's in the OCML package, we're
dealing with OCML, so it's pretty redundant.  ‘domain’ makes more
sense.

*** ensure-vanilla-class/2 can be merged

*** webonto goodies

Steal any general purpose OCML utilities from WebOnto.

*** call-with-ocml-thread-safety

Make sure we get all the important variables!  globals.lisp is
a *lot* longer than this function...  We can also introduce a
special, *with-thread-safety*, which would indicate the prior
invocation of call-with-ocml-thread-safety and warn about it.

*** ocml-load

generalize the muffled warnings for all ocml loads.  new variable:
(defvar *ontology-warnings* nil).  Might want to check (by looking at
the message string) what kind of warnings to ignore.
http://www.lisp.org/HyperSpec/Body/res_muffle-warning.html

***

the def-ontology form does not evaluate the :namespace-uri initarg.
this is problematic.  we should fix this, and any other cases for
which it makes sense.

*** in theories5

when redefining an ontology, we do a lot of setf'ing.  Shouldn't we
use a shared-initialize instead?  That'd save typing, and make sure
other things happen right (if they need to happen at all).

** Ontology packaging

I think we need a three-layer org.  The OCML engine (ocml), the
general purpose OCML library (ocml-library), and the applications
(irs, kmi-impact) etc.

*** Basic

Add the basic stuff from the library?  Or keep it separate?  I think
we should add the basic elements, although if we go to the three-layer
model above, the basic stuff should move to the library, too.  That
makes test cases a bit tricky, perhaps...

** Uncompiled files

We don't currently build the files back-chain-compiler, dthreeify,
expressions, methods, operator.  Why not?  Should we, or should they
be rm'd?

* Namespaces

Variables: how do swrl etc deal with it?  What about variables?  Do we
need to bother about these?  I'm ignoring them at the moment...
They *should* just work, as long as I don't stomp on the #\? naming
convetion...  Where *does* the #\? go???

The home ontology can be added to the symbol's plist.

** Namespaces and ontologies

** Merging old and new

At present, if an ontology declares a prefix which overrides an
inherited one, we lose a prefix for that namespace.  This is
unacceptable: some kind of disambiguation must happen, by uniquifying
the inherited prefix.

** with-namespaces

This mutates current lookups.  A putative WITH-NAMESPACES form would
push and pop them.  But WITH-NAMESPACES has limited use, because the
reader does its thing before the form gets evaluated.  It could be
used around (load)s, or when printing using a modified symbol printer.


Local variables:
mode: outline
End:
